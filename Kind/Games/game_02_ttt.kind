// Piece
type TicTacToe.Piece {
  O
  X
}

// Game state
type TicTacToe {
  new(
    turn: Nat
    board: List<List<Maybe<TicTacToe.Piece>>>
  )
}

// Example of a finished game
// TicTacToe.new(
//   7,
//   [
//     [some(TicTacToe.Piece.X), some(TicTacToe.Piece.X), some(TicTacToe.Piece.O)],
//     [none                   , some(TicTacToe.Piece.X), some(TicTacToe.Piece.O)],
//     [none                   , some(TicTacToe.Piece.O), some(TicTacToe.Piece.X)]
//   ]
// )


// The initial board state
// An empty board
TicTacToe.init: TicTacToe
  TicTacToe.new(0, [
    [none, none, none],
    [none, none, none],
    [none, none, none]
  ])

// Gets the state of a given position in the board
// x = Position in the row
// y = Position in the column
TicTacToe.get(x: Nat, y: Nat, game: TicTacToe): Maybe<TicTacToe.Piece>
  let row = List.get!(y, game@board)

  let piece = List.get!(x, row <> [])

  case piece {
    none: none
    some: piece.value
  }


// If possible, converts the user input to a coordinate {x, y}
// A valid inputs is any pair of 2 numbers separated with a space:
// "0 2"
// "4 4"
// Invalid inputs:
// "banana"
// "   "
TicTacToe.read(input: String): Maybe<Pair<Nat, Nat>>
  let strings = String.split(input, " ")

  case Nat.eql(List.length!(strings), 2) {
    true: 
      let x = List.get!(0, strings)
      let y = List.get!(1, strings)
      some({Nat.read(x <> "0"), Nat.read(y <> "0")})
    false: none
  }

// Checks if a movement is valid
// A valid movement is any movement inside the 3x3 board if the tile is unnocupied
TicTacToe.is_move_valid(coord: Pair<Nat, Nat>, game: TicTacToe): Bool
  case Nat.ltn(coord@fst, 3) Nat.ltn(coord@snd, 3) TicTacToe.get(coord@fst, coord@snd, game) {
    true true none: true
  } default false


// Who is the next one to play?
TicTacToe.next_piece(game: TicTacToe): TicTacToe.Piece
  if Nat.is_even(game@turn) then 
    TicTacToe.Piece.X 
  else 
    TicTacToe.Piece.O


// From an input, adds X or O (decided from TicTacToe.next_piece) at given location and increments the turn
TicTacToe.move(coord: Pair<Nat, Nat>, game: TicTacToe): TicTacToe
  open game  
  let piece = TicTacToe.next_piece(game)
  let row = List.get!(coord@snd, game.board)
  let newRow = List.set!(coord@fst, some(piece), row <> [])
  let newBoard = List.set!(coord@snd, newRow, game.board)
  TicTacToe.new(Nat.succ(game.turn), newBoard)


// Checks if 2 pieces are equal
TicTacToe.Piece.eql(a: Maybe<TicTacToe.Piece>, b: Maybe<TicTacToe.Piece>): Bool
  case a b {
    some some: case a.value b.value {
      X X: true
      O O: true
    } default false
  } default false


TicTacToe.winner.go(a: Pair<Nat, Nat>, b: Pair<Nat, Nat>, c: Pair<Nat, Nat>, game: TicTacToe): Maybe<TicTacToe.Piece>
  let get = (p: Pair<Nat, Nat>) TicTacToe.get(p@fst, p@snd, game)

  let f = (p1: Maybe<TicTacToe.Piece>, p2: Maybe<TicTacToe.Piece>)
    if TicTacToe.Piece.eql(p1, p2) then
      p1
    else
      none
  let xs = [get(a), get(b), get(c)]

  case xs {
    nil: none
    cons: List.foldl!!(xs.head, f, xs.tail)
  }

// Determines a winner if there is one
TicTacToe.winner(game: TicTacToe): Maybe<TicTacToe.Piece>
  let result = none
  for x in [0, 1, 2] with result:
    let vertical = TicTacToe.winner.go({x, 0}, {x, 1}, {x, 2}, game)
    let horizontal = TicTacToe.winner.go({0, x}, {1, x}, {2, x}, game)
    Maybe.or!(result, Maybe.or!(vertical, horizontal))

  let dia1 = TicTacToe.winner.go({0, 0}, {1, 1}, {2, 2}, game)
  let dia2 = TicTacToe.winner.go({0, 2}, {1, 1}, {2, 0}, game)

  Maybe.or!(result, Maybe.or!(dia1, dia2))

// Converts the piece into a text to be shown
TicTacToe.Piece.show(a: Maybe<TicTacToe.Piece>): String
  case a {
    none: " "
    some: case a.value {
      X: "X"
      O: "O"
    }
  }

// Shows the board
// Example:
//
//  X | X | O 
// -----------
//  O | O | X 
// -----------
//  X | O | X 
//
TicTacToe.show(game: TicTacToe): String
  open game
  let result = ""

  for y in [0, 1, 2] with result:

    for x in [0, 1, 2] with result:
      let piece = TicTacToe.Piece.show(TicTacToe.get(x, y, game))
      if Nat.eql(x, 1) then 
        result | " | " | piece | " | " 
      else 
        result | piece

    if (Nat.eql(y, 2)) then 
      result 
    else 
      result | "\n--|---|--\n"

  result

game_02_ttt: IO<Unit>
  IO {
    // Prints the initial board
    let ttt = TicTacToe.init
    IO.print(TicTacToe.show(ttt))
    TicTacToe.play(ttt)
  }


// Do not edit below this line
TicTacToe.play(game: TicTacToe): IO<Unit>
  IO {
    IO.print("Where do you wanna move?")
    // Receives user input
    get line = IO.get_line

		// Converts input into coordinates
		let coords = TicTacToe.read(line)

		get game =
			case coords {
				none: IO {
					IO.print("Invalid entry")
					return game
				}
				some:
					// Checks if a movement is valid
					let is_move_valid = TicTacToe.is_move_valid(coords.value, game)

					if is_move_valid then IO {
						// Returns the game after
						let new_game = TicTacToe.move(coords.value, game)
						return new_game
					}
					else IO {
						IO.print("You cannot play there!")
						return game
					}
			}

    // Prints the result
    IO.print(TicTacToe.show(game))

    // Checks who is the winner
    let Winner = TicTacToe.winner(game)
    open game

    // If there is no winner, checks if its a draw
    case Winner {
      none:
        if Nat.eql(game.turn, 9) then
          IO.print("Draw!")
        else TicTacToe.play(game)
      some: case Winner.value {
        X: IO.print("X Wins!")
        O: IO.print("O Wins!")
      }
    }
  }